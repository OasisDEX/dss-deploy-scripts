#!/usr/bin/env bash

# shellcheck source=lib/common.sh
. "${LIB_DIR:-$(cd "${0%/*}/../lib"&&pwd)}/common.sh"

# Deploy Values or Medians + OSMs (if delay > 0) (no solc optimization)
dappBuild osm
dappBuild testchain-medians
copyAbis testchain-medians

tokens=$(jq -r ".tokens | keys_unsorted[]" "$CONFIG_FILE")
for token in $tokens; do
    pipAddr=$(jq -r ".tokens.${token} | .pip | values" "$CONFIG_FILE")
    if [[ "$pipAddr" == "" ]]; then
        type=$(jq -r ".tokens.${token} | .pipDeploy | .type | values" "$CONFIG_FILE")
        # Deploy Medianizer as Feed
        if [[ "$type" == "median" ]]; then
            contract=$(dappCreate testchain-medians "Median${token}USD")
            eval "export PIP_${token}=${contract}"
            signers=$(jq -r ".tokens.${token} | .pipDeploy | .signers | .[]" "$CONFIG_FILE")
            # Approve oracle price feed providers
            for signer in $signers; do
                seth send "$(eval echo "\$PIP_${token}")" 'lift(address)' "$signer"
            done
            # Set quorum for Medianizer
            seth send "$(eval echo "\$PIP_${token}")" 'setBar(uint256)' "$(seth --to-uint256 3)"
            # Whitelist Omnia relayer to read price from Medianizer
            seth send "$(eval echo "\$PIP_${token}")" 'kiss(address)' "$OMNIA_RELAYER"
        fi
        # Deploy DSValue as Feed
        if [[ "${type}" == "value" ]]; then
            contract=$(dappCreate osm DSValue)
            eval "export PIP_${token}=${contract}"
        fi
    else
        eval "export PIP_${token}=${pipAddr}"
        copyAbis osm
        copyAbis testchain-medians
    fi
    eval "export VAL_${token}=\$PIP_${token}"
done

# Deploy Multicall (no solc optimization)
dappBuild multicall
MULTICALL=$(dappCreate multicall Multicall)
log "multicall deployed"

# Deploy Token Faucet (no solc optimization)
dappBuild token-faucet
FAUCET=$(jq -r ".faucet | values" "$CONFIG_FILE")
test -z "$FAUCET" && FAUCET=$(dappCreate token-faucet TokenFaucet "$(seth --to-uint256 "$(seth --to-wei 50 ETH)")") && log "token faucet deployed"

# Deploy Guard for Gov and IOU tokens (no solc optimization)
dappBuild ds-guard
MCD_GOV_GUARD=$(dappCreate ds-guard DSGuard)
log "ds-guard deployed"

# Deploy ProxyRegistry (no solc optimization)
dappBuild proxy-registry
PROXY_FACTORY=$(dappCreate proxy-registry DSProxyFactory)
PROXY_REGISTRY=$(dappCreate proxy-registry ProxyRegistry "$PROXY_FACTORY")
log "proxy-registry deployed"

PATH="$DAPP_LIB/dss-deploy/bin:$PATH"

# Deploy Fabs (no solc optimization)
deploy-fab
# shellcheck source=/dev/null
. "load-fab-$(seth chain)"
rm "load-fab-$(seth chain)"
log "fabs deployed"

# Set the pause delay to 0 in order to make the needed initial configurations
export MCD_PAUSE_DELAY=0

# Make sure there is not $MCD_ADM set, so a temporary roles is created as authority (to handle variables set up easier)
unset MCD_ADM

MCD_GOV=$(jq -r ".gov | values" "$CONFIG_FILE")
if [[ -z "$MCD_GOV" ]]; then
    # It means the GOV token will be created now in the next deployment script call, then we can send funds to the Faucet and set permissions to FLOP
    newGovToken=true
else
    newGovToken=false
    export MCD_GOV
fi

# Deploy MCD Core Contratcs (solc optimized)
deploy-core
# shellcheck source=/dev/null
. "load-mcd-$(seth chain)"
rm "load-mcd-$(seth chain)"
log "core deployed"

# Mint Gov Token, send to the Faucet and set permissions if a new token
if [[ "$newGovToken" == true ]]; then
    seth send "$MCD_GOV" 'mint(address,uint256)' "$FAUCET" "$(seth --to-uint256 "$(seth --to-wei 1000000 ETH)")"
    seth send "$MCD_GOV" 'setAuthority(address)' "$MCD_GOV_GUARD"
    seth send "$FAUCET" 'gulp(address)' "$MCD_GOV"
    # Allow Flop to mint Gov token
    seth send "$MCD_GOV_GUARD" 'permit(address,address,bytes32)' "$MCD_FLOP" "$MCD_GOV" "$(seth --to-bytes32 "$(seth sig 'mint(address,uint256)')")"
fi

# Deploy Collaterals (no solc optimization)
tokens=$(jq -r ".tokens | keys_unsorted[]" "$CONFIG_FILE")
for token in $tokens; do
    ilks=$(jq -r ".tokens.${token}.ilks | keys_unsorted[]" "$CONFIG_FILE")

    gemAddr=$(jq -r ".tokens.${token} | .gem | values" "$CONFIG_FILE")
    eval "export ${token}=${gemAddr}"

    for ilk in $ilks; do
        deploy-ilk-"$(echo "$token" | tr '[:upper:]' '[:lower:]')" "$ilk"
        log "$token deployed"

        # shellcheck source=/dev/null
        . "load-ilk-$(echo "$token" | tr '[:upper:]' '[:lower:]')-$(echo "$ilk" | tr '[:upper:]' '[:lower:]')-$(seth chain)"
        rm "load-ilk-$(echo "$token" | tr '[:upper:]' '[:lower:]')-$(echo "$ilk" | tr '[:upper:]' '[:lower:]')-$(seth chain)"

        # If the ilk token was created by the previous deployment script call (new token) and it is not ETH, then we can send funds to the Faucet
        if [[ "$token" != "ETH" && "$gemAddr" == "" ]]; then
            seth send "$(eval echo "\$$token")" 'transfer(address,uint256)' "$FAUCET" "$(seth --to-uint256 "$(seth --to-wei 999000 ETH)")"
        fi
        export SKIP_BUILD=true
    done
done

# As all initial collaterals were deployed, we can remove authority of the deployment contract from the core contracts
seth send "$MCD_DEPLOY" 'releaseAuth()'
for token in $tokens; do
    ilks=$(jq -r ".tokens.${token}.ilks | keys_unsorted[]" "$CONFIG_FILE")
    for ilk in $ilks; do
        seth send "$MCD_DEPLOY" 'releaseAuthFlip(bytes32)' "$(seth --to-bytes32 "$(seth --from-ascii "${token}-${ilk}")")"
    done

    log "auth removed for $token"
done

# Deploy Pause Plan - Library functions for the Pause (no solc optimization)
MCD_GOV_ACTIONS=$(dappCreate dss-deploy GovActions)
log "gov actions deployed"

unset SKIP_BUILD

dappBuild dss-proxy-actions

# Deploy Proxy Actions (no solc optimization)
PROXY_ACTIONS=$(dappCreate dss-proxy-actions DssProxyActions)

# Deploy CdpManager (no solc optimization)
CDP_MANAGER=$(dappCreate dss-proxy-actions DssCdpManager "$MCD_VAT")
GET_CDPS=$(dappCreate dss-proxy-actions GetCdps)
log "proxy actions deployed"

# Deploy Pause Proxy Actions (support contract for executing initial set up of the dss system)
dappBuild testchain-pause-proxy-actions

PROXY_PAUSE_ACTIONS=$(dappCreate testchain-pause-proxy-actions TestchainPauseProxyActions)
seth send "$PROXY_REGISTRY" 'build()'
log "pause actions deployed"

# Get a proxy for the deployer address
PROXY_DEPLOYER=0x"$(seth call "$PROXY_REGISTRY" 'proxies(address)(address)' "$ETH_FROM")"

# Set the proxy address as root of the roles (in order to be able to do all the variables set up)
seth send "$MCD_ADM" 'setRootUser(address,bool)' "$PROXY_DEPLOYER" true

# Deploy chief as new $MCD_ADM (no solc optimization)
dappBuild ds-chief
MCD_IOU=$(dappCreate ds-chief DSToken "$(seth --to-bytes32 "$(seth --from-ascii "IOU")")")
seth send "$MCD_IOU" 'setAuthority(address)' "$MCD_GOV_GUARD"
seth send "$MCD_IOU" 'setOwner(address)' "0x0000000000000000000000000000000000000000"
MCD_ADM=$(dappCreate ds-chief DSChief "$MCD_GOV" "$MCD_IOU" 5)
seth send "$MCD_GOV_GUARD" 'permit(address,address,bytes32)' "$MCD_ADM" "$MCD_IOU" "$(seth --to-bytes32  "$(seth sig 'mint(address,uint256)')")"
seth send "$MCD_GOV_GUARD" 'permit(address,address,bytes32)' "$MCD_ADM" "$MCD_IOU" "$(seth --to-bytes32  "$(seth sig 'burn(address,uint256)')")"
seth send "$MCD_GOV_GUARD" 'setOwner(address)' "0x0000000000000000000000000000000000000000"
log "chief deployed"

# Deploy Vote Proxy Factory (no solc optimization)
dappBuild vote-proxy --use solc:0.4.25
VOTE_PROXY_FACTORY=$(dappCreate vote-proxy VoteProxyFactory "$MCD_ADM")
log "vote proxy factory deployed"

# Copy dss-deploy abi files
copyAbis dss-deploy

for token in $tokens; do
    ILKS_VARS+=",
    \"${token}\": \"$(eval echo "\$${token}")\""
    if [[ "$(eval echo "\$VAL_${token}")" != "" ]]; then
    ILKS_VARS+=",
    \"VAL_${token}\": \"$(eval echo "\$VAL_${token}")\""
    fi
    ILKS_VARS+=",
    \"PIP_${token}\": \"$(eval echo "\$PIP_${token}")\""
    ilks=$(jq -r ".tokens.${token}.ilks | keys_unsorted[]" "$CONFIG_FILE")
    for ilk in $ilks; do
    ILKS_VARS+=",
    \"MCD_JOIN_${token}_${ilk}\": \"$(eval echo "\$MCD_JOIN_${token}_${ilk}")\""
    ILKS_VARS+=",
    \"MCD_FLIP_${token}_${ilk}\": \"$(eval echo "\$MCD_FLIP_${token}_${ilk}")\""
    done
done

# Generate addresses.json file
cat > "$OUT_DIR"/addresses.json <<EOF
{
    "ETH_FROM": "$ETH_FROM",
    "MULTICALL": "$MULTICALL",
    "FAUCET": "$FAUCET",
    "MCD_DEPLOY": "$MCD_DEPLOY",
    "MCD_GOV": "$MCD_GOV",
    "MCD_GOV_GUARD": "$MCD_GOV_GUARD",
    "MCD_IOU": "$MCD_IOU",
    "MCD_ADM": "$MCD_ADM",
    "VOTE_PROXY_FACTORY": "$VOTE_PROXY_FACTORY",
    "MCD_VAT": "$MCD_VAT",
    "MCD_JUG": "$MCD_JUG",
    "MCD_CAT": "$MCD_CAT",
    "MCD_VOW": "$MCD_VOW",
    "MCD_JOIN_DAI": "$MCD_JOIN_DAI",
    "MCD_FLAP": "$MCD_FLAP",
    "MCD_FLOP": "$MCD_FLOP",
    "MCD_PAUSE": "$MCD_PAUSE",
    "MCD_PAUSE_PROXY": "$MCD_PAUSE_PROXY",
    "MCD_GOV_ACTIONS": "$MCD_GOV_ACTIONS",
    "MCD_DAI": "$MCD_DAI",
    "MCD_SPOT": "$MCD_SPOT",
    "MCD_POT": "$MCD_POT",
    "MCD_END": "$MCD_END",
    "MCD_ESM": "$MCD_ESM",
    "PROXY_ACTIONS": "$PROXY_ACTIONS",
    "CDP_MANAGER": "$CDP_MANAGER",
    "GET_CDPS": "$GET_CDPS",
    "PROXY_FACTORY": "$PROXY_FACTORY",
    "PROXY_REGISTRY": "$PROXY_REGISTRY"$ILKS_VARS,
    "PROXY_PAUSE_ACTIONS": "$PROXY_PAUSE_ACTIONS",
    "PROXY_DEPLOYER": "$PROXY_DEPLOYER"
}
EOF

"$LIBEXEC_DIR"/set-line

"$LIBEXEC_DIR"/set-wait

"$LIBEXEC_DIR"/set-bump

"$LIBEXEC_DIR"/set-sump

"$LIBEXEC_DIR"/set-hump

"$LIBEXEC_DIR"/set-beg "flap"

"$LIBEXEC_DIR"/set-ttl "flap"

"$LIBEXEC_DIR"/set-tau "flap"

"$LIBEXEC_DIR"/set-beg "flop"

"$LIBEXEC_DIR"/set-ttl "flop"

"$LIBEXEC_DIR"/set-tau "flop"

"$LIBEXEC_DIR"/poll-deploy

"$LIBEXEC_DIR"/set-ilks-price

"$LIBEXEC_DIR"/set-ilks-pip-whitelist

"$LIBEXEC_DIR"/set-ilks-mat

setLinesMode=$(jq -r ".setLinesMode" "$CONFIG_FILE")
if [[ $setLinesMode = "direct" ]]; then
    "$LIBEXEC_DIR"/set-ilks-line
elif [[ $setLinesMode = "vote" ]]; then
    "$LIBEXEC_DIR"/set-ilks-spell-line
fi

"$LIBEXEC_DIR"/set-ilks-duty

"$LIBEXEC_DIR"/set-ilks-spotter-poke

"$LIBEXEC_DIR"/set-ilks-chop

"$LIBEXEC_DIR"/set-ilks-lump

"$LIBEXEC_DIR"/set-ilks-beg

"$LIBEXEC_DIR"/set-ilks-ttl

"$LIBEXEC_DIR"/set-ilks-tau

if [[ -f "$CASE" ]]; then
    "$CASE"
fi

"$LIBEXEC_DIR"/set-ilks-osm

"$LIBEXEC_DIR"/set-pause-auth-delay
